# prokishi

将棋エンジンはUSIと呼ばれるプロトコルによって制御されて動作しています。
このプロトコルはプロセスの標準入力と標準出力で対話を行って動作しています。
よって将棋エンジンを組み込める将棋ソフトはエンジンと同じ端末内で動作することを余儀なくされます。

prokishiエンジンはprokishiからprokishi-serverにUSIプロトコルを転送し、サーバ側で評価を行うことで将棋ソフトを実行している端末の負荷を下げることができます。

USIプロトコルとサーバをプロキシする仕組みが「prokishi」です。

## インストール

INSTALL.md をご覧ください

## 利用例１：配信者

配信を行っている方は評価値などを表示していますが、配信している端末と評価を出している端末は同一端末をおそらく使っていると思います。これを分離することである程度配信端末の負荷を軽減できると思います。

## 利用例２：評価値サーバを構築する

UIがWindowsでエンジンがLinux,Macしか対応してない(あるのか？)っていう場合でも、prokishiを通して実行することが可能です。(prokishi-serverをそっちでビルドする必要がありますが)
また逆もしかりです。

prokishi-serverを複数構築して、色々なエンジンをそれぞれの端末で動作させることができます。・・・自分で書いててそこまでしてやる人が世界に何人いるのかって感じですが、技術的には可能になります。

サーバのコストを度外視すれば、将棋エンジンサービスを作ることも可能です。

技術的にはサーバサイド側をいじってUSI(標準出力、入力)に縛られないエンジン開発も可能にはなります。

## 利用例３：処理プロセスをわける

これは設計思想になかったのですが、開発中の体感として同一端末で実行しててもエンジンの実行箇所を分けるだけで少し位は処理が軽減される可能性があります。(あくまで体感です)
UI部分が子プロセスで実行しているのに対して、prokishiでは全く関係ないプロセスで動作します。そのためちょっとは処理に影響が出ているのかもしれません。

# テストについて

将棋ソフトとの連携テストはShogiGUIを利用して行っています。

# USIプロトコルについて

id name,id author,quit以外のコマンドはUSIプロトコルを純粋に処理します。

名称とバージョンについては

- {engine_name} (prokishi v0.0.0)
- {engine_author} (secondarykey)

というベースのエンジンにこのエンジンの編集が入ります。

quit では終了処理が入ります。またエンジン側のプロセスが終了した場合、可能であればサーバ側にquitを送りますが、現状ゴミになる可能性があります。(サーバ側に動作エンジンをkillする方法などを提供予定)

# 動作保障

通信を介している以上、通常動作よりは不安定になると思います。
利用に際してのいかなる問題も当方では責任を追いかねます。

# ログについて

prokishi,prokishi-serverは実行位置にログファイルを出力します。

prokishi は設定ファイルのlogLevelを"debug"に設定し、prokishi-serverは実行時に-v にするとUSIのやり取りも全て記録されます。

# development

サーバとの連携はgrpcを利用しています。

grpc code generate:

```
protoc --go_out=. --go-grpc_out=. api.proto
```

## build

開発時に都合がいいようにビルドした場合とiniファイルの位置を切り替えています。
build 時にバージョンを指定するはずなので、バージョンによってビルド実行しているものかを判定して動作させます。

その為、新たにビルドしてご利用する場合はバージョンの指定を行ってください。

```
go build -ldflags "-X main.version=0.0.0" -o prokishi.exe main.go
```

という風にビルドしてください。
同じ名称でビルドして利用される場合はできればバージョンはそれとわかるようにしてください。

